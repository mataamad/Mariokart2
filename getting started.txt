How to build the project and load code onto the boards:
first take a look at:
https://github.com/team-ramrod/mariokart/wiki/Software-Compilation

I'd recommend that instead of following their information just use this package on linux:
http://torrentula.to.funpic.de/tag/arm-none-eabi-gcc/
and then add this path to your .bashrc file (or copy and paste it in each time you start a terminal) so that the compiler can be found:
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/CodeSourcery/arm-2011.09/bin"

you should be able to run arm-none-eabi-gcc, and get a 'no input files' error.
navigate to mariokart/Software and (as a superuser) type:
make
this should make the C part of the project.

You'll also need a copy of OpenOCD.  This will probably be available in your linux repo, or just find a copy of it online.

Next connect the board you wish to program with one of the department usb-to-jtag connectors.  Start a new terminal, navigate to mariokart/Software, and type make OCD to start OpenOCD.  In the other terminal load the program onto the board using: (e.g. for comms board)
make program-comms

Note that you'll have to reset the board by cycling the power to start it up again.
The other option is to use:
make debug-comms
which will load the program and then start a paused session of gdb - type (c)ontinue to start the program.

Note that you can connect a UART cable if you want serial output from the boards - I didn't do this because there weren't any cables made up and I didn't have many connectors left to make new ones - check the wiki from 2011 for more info on doing it.


Here was my usual terminal entry:
    source /home/mwwigley/.bashrc
    cd mariokart
    cd Software
    sudo su
    make ocd

    start a new terminal,
    navigate to Software
    sudo su
    make program-brake

    disconnect and reconnect power to run program
    might need to restart OCD after disconnecting and reconnecting



The state of the project:
all major parts of the project should be in working order.
The boards should be able to communicate via canbus, and configure into their running state.  It  should be possible to get and set all values via the python API(in Software/highLevelControl), and the tests should run.

Debugging states:
startup state:
make sure all 5 boards are plugged in.  If you modify main.c in comms, you can reduce the number of boards needed for startup to complete, but for some reason the canbus code does not like having only two boards connected so don't reduce it to 2 (doesn't even matter if the third board just has no code on it so you can reduce the required boards to 2 and plug in another with no protocol code on it as a workaround).
calibration state: 
The usual blocking board is the steering board or the brake board as they are the only ones with calibration phases - you'll need to tap both the limit switches on the steering board(and make sure the encoder + motor board is working), and make sure the brake actuator and pot is connected correctly so that it can move to the 'brake on' position and finish its calibration.


Here is a todo list of the general things which should be completed on the project:
buy a whole lot of the correct connectors, and solder them up and use them instead of flying leads.  The problem is that the connectors on the boards are really terrible - they just break all the time, it's barely worth using them.
make/get another two ethernet cables (had a couple stolen, so you'll have to make some more)
load code onto the student board and ensure that it works correctly with SPI acceleration setting from the motor board
get P(ID) control working on the motor board to set the speed instead of just acceleration.
put the actuators on the kart and try them out, get the kart moving in at least a couple of ways and video it
Currently removing or crasing a board doesn't cause the system to transition to an error state.  acknowledgements need to be implemented.
getting data via USB seems to be slow - may need to just periodically send all data to the python code in a big chunk, and run a thread which saves it - otherwise people using repeated Get's from the API might have their programs horribly slowed.
properly implement and test closed loop speed control
heatsink may be needed on the steering motor driver - only rated 2 amps without one. if it gets hot add one.


Board specific information and problems:

Sensor board:
The 12v regulator is not working(usually it only functions when Pbatt is plugged in as it needs more than the 5V the canbus provides so make sure when you're testing it you have a Pbatt plugged in).  It's needed because the inductive speed sensor needs at least 12 volts (12 to 30 volts) although it appeared to run on 5 volts.  For now I've just powered the speed sensor directly from Pbatt or another boards 12V terminal.
The connector also needs fixing for the speed sensor (no point fixing it until 12 volts works though).
The speed sensor has the following wires:
blue - ground
black - measure line
brown - Vcc
internally and over CANBUS and USB the brake position is measured in a 1000*meters/second value.
Also note that this speed sensor hasn't been tested on a moving kart, so make sure it's actually accurate - in principle it should be.  I haven't even looked at how to connect it to the kart.




Steering board:
For some reason (it's been that way since I got the boards) one of the PWM pins didn't work on this board - I couldn't figure out why, there don't appear to be any shorts or anything.  I've used an alternate PWM pin on the black line.
At the moment the steering board just sends an integer angle in degrees across CANBUS/USB, limiting steering accuracy to 1 degree.  You might want to increase the accuracy here, but for steering degree level accuracy is probably enough.

Brake board:
A track has been ripped off the potentiomenter sense line(wasn't me!).  There aren't any test points along this line, and it's one of the important ones.  At the moment it's just taped onto a through hole but that's going to come loose all the time.  It's probably a good idea to find another ADC pin and use that instead in the long term.
The colour coding of the potentiometer wires is:
red - Vcc
orange - pot measure
brown (and black on the board) - ground.
It's another thing which doesn't have a proper connector.
internally and over CANBUS and USB the brake position is measured in a 0-1023 ADC value

Motor board:
The motor board should talk to the student board(control board) on go-kart but it hasn't been tested properly as I blew up a student board.  A connector cable will have to be made eventually.  For now there is a RJ12 connector I've supplied that you can just connect to the test pins. The colours of the supplied RJ12 connector are:
white - SCK
black - ground
red - MISO
green - vcc
yellow - reset
blue - MOSI
As the motor board is acting as master you'll need connect MOSI(master output slave input), ground, and SCK(clock) to the correct test pins.
Note that you need to keep the cable length as short as possible or the signal gets too wrecked.

You'll need to flash the student board with new code (see /mariokart/student_board) with the new SPI code.
for the SPI transfers to work you'll need to pull the SS pin on the student board low, so don't forget to do this or you won't get data transfer.

The student board reads single bytes over SPI, and sets its pwm duty percent to 1-(value)/256 [the pwm is inverting], since it's minimum duty cycle is 10% you shouldn't send values larger than about 230. the 0-256 value is also used over CANBUS and USB.


Loading code onto the student board:
to do this the easiest way is to use the provided parallel port connector and do it on a windows xp machine in the DSL - you should just be able to run the batch file avr-gcc-20071221 and then type make to make the code, and use ld to load file (e.g ld main for the standard build). You'll need to provide at least 12 volts on the 24v pin while flashing the board.
Note that the rj45 wires are pretty horrible so make sure that the parallel port connection wires are ok.
Also note that since I fried one of the student boards (put 24 volts onto pwm by accident) I couldn't finish testing the code on the student board.  I got to the point where I was sending arbitary values between 0 and 256 via SPI, so I think the code I've provided should work but if it doesn't SPI transfers should work from the get go (connect blue line on the rj45 to MOSI on the motor board, the white line to SCK (clock), and the black line to ground on the motor board.  Note that the most important problem I had is that SS (slave select) needs to be pulled low on the atmega8 for data to transfer.  This is a problem because the pin isn't connected to a track so you'll need to solder on a flying lead and connect it directly to ground.
Also be careful in that the altium schematic provided does not seem to match the actual student boards (nor does the pcb layout match perfectly, but it is much closer). SS is pin 14, and is to the right of the PWM pin.

Motor drivers:
The motor drivers were purchased from mindkits, I've supplied their datasheets.  PWM output from the brake and steering board is 3.3 volts, and currently at 5.8kHz. If you want to increase the pwm speed past 10khz(to a max of 20kHz) for some reason you'll need to enable the fast slew rate jumper on the motor drivers.  You might need to add heatsinks to the motor drivers.  THey auto cutoff(in a gradual fashion) so you shouldn't be able to break them though.  Last year(2011)the team designed and built their own motor driver boards, these were either broken or I managed to wreck them somehow.  If you decide you want to use one of theirs there is still one spare motor driver chip for them so you could replace it and use theirs =.
I've used the following wire colours to connect the motor drivers:
red - 3.3 volts for enable pin
orange - in2
black - in1

